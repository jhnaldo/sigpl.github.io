<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<html>
<head>
<link rel="stylesheet" type="text/css" href="/style.css">
<title>SIGPL 2016 동계 워크숍</title>
</head>
<body>

<h2> Light talk(2) - 좌장: 임현승 교수(강원대학교)</h2>
<table border="1" bordercolor="#a0a0a0" cellspacing="0">
<tr><th style="width:90px">발표</th>
  <th style="width:330px">
권기창(광주과학기술원)
  </th><th style="width:110px">시간</th><th style="width:110px">
15:20-15:25
  </th></tr>
<tr align="center"><th>제목 </th>
<td colspan="3" align="left"> 
An Efficient Choice of Java Object Model with Preemptable Code Offloading
</td>
<tr align="center"><th>요약 </th>
<td colspan="3" align="left"> 
Although the technology for mobile device is constantly improving for the last ten years, the battery capacity is a major problem for using the mobile devices. Since it remains alive either only couple of hours for laptops or at most one day for smartphones. Code offoading is a kind of increasing energy effciency to live longer. In this paper, we evaluate Java object models with preemptable code offoading. We suggest the choice of Java object model.
</td>
<tr><th style="width:90px">발표</th>
  <th style="width:330px">
    강성중(광주과학기술원)
  </th><th style="width:110px">시간</th><th style="width:110px">
15:25-15:30
  </th></tr>
<tr align="center"><th>제목 </th>
<td colspan="3" align="left"> 
JeannieCL: Granting JNI with parallel environment
</td>
<tr align="center"><th>요약 </th>
<td colspan="3" align="left"> 
his talk introduces JeannieCL, which integrates two frameworks - Jeannie and OpenCL. Jeannie enables to use JNI programming without including jni.h header, using only one source code. Using OpenCL, this is expected to be parallelized. We can look for better performance for arallelized Java-C program. 
<tr><th style="width:90px">발표</th>
  <th style="width:330px">
고봉석(광주과학기술원)
  </th><th style="width:110px">시간</th><th style="width:110px">
15:30-15:35
  </th></tr>
<tr align="center"><th>제목 </th>
<td colspan="3" align="left"> 
Empirical Study of Real World Multilingual Programs and Their Bugs
</td>
<tr align="center"><th>요약 </th>
<td colspan="3" align="left"> 
This talk discusses plans and methodology for analyzing usage of multilingual programs and their program errors. High-level programming languages can support foreign function interface (FFI) to imporve their performance or use legacy codes. Multilingual programs have multilingual program bugs and many researchers develop various debugging tool to find bugs. First, I analyze papers for multilingual programs. Unfortunately there are no benchmarks for multilingual program bug research. Therefore many researchers select test program with ad-hoc process or random selection.  Then I find multilingual programs each Ubuntu version to analyze trend of multilingual program. My next plan is that collecting real world multilingual program bugs with bug tracking system. If this study success, I can provide real world multilingual program bugs in benchmark form.
</td>

<tr><th style="width:90px">발표</th>
  <th style="width:330px">
안수민(광주과학기술원)
  </th><th style="width:110px">시간</th><th style="width:110px">
15:35-15:40
  </th></tr>
<tr align="center"><th>제목 </th>
<td colspan="3" align="left"> 
Empirical Analysis of Ocaml/C Program Errors
</td>
<tr align="center"><th>요약 </th>
<td colspan="3" align="left"> 
Bugs appearing in multilingual programs are hard to be analyzed because they usually from foreign function interfaces. We present empirical analysis of the OCaml/C program errors, occurring on Ocaml’s foreign function calls to C. In this paper, we concentrate on LablGtk, which is an OCaml interface to GTK+ 1.2 and 2.x. It provides a strongly-typed, yet comfortable, object-oriented interface compatible with GTK+’s dynamic typing thorugh OCaml’s rich type system. Most widgets and methods are available, along with many examples. And our results of analysis would be used to fix bugs that are not fixed yet and help to make auto debugging system on multilingual programs, O-Saffire or MUSEUM.
</td>
<tr><th style="width:90px">발표</th>
  <th style="width:330px">
한승훈(광주과학기술원)
  </th><th style="width:110px">시간</th><th style="width:110px">
15:40-15:45
  </th></tr>
<tr align="center"><th>제목 </th>
<td colspan="3" align="left"> 
Source code level debugger for jikes RVM
</td>
<tr align="center"><th>요약 </th>
<td colspan="3" align="left"> 
The Jikes RVM is a virtual machine for reasearch. When researching with Jikes RVM, sometime we want to debug Jikes RVM in source code level. But there are no debugger presenting source code. This talk about idea about implementation of source code level debugger for Jikes RVM.
</td>
<tr><th style="width:90px">발표</th>
  <th style="width:330px">
박창희(KAIST)
  </th><th style="width:110px">시간</th><th style="width:110px">
15:45-15:50
  </th></tr>
<tr align="center"><th>제목 </th>
<td colspan="3" align="left"> 
스트링 도메인에 간단한 정규식을 활용하여 효율적으로 jQuery 정적 분석하기
</td>
<tr align="center"><th>요약 </th>
<td colspan="3" align="left"> 
jQuery는 가장 많이 쓰이는 JavaScript 라이브러리인 반면 현재 존재하는 최첨단 JavaScript 정적 분석기들은 jQuery를 이용하는 간단한 프로그램 마저 합리적인 시간내에 분석을 해내지 못 하고 있습니다. 이 발표에서는 jQuery를 이용하는 프로그램 분석을 좀더 효율적으로 하기 위해 간단한 정규식의 활용 방안에 대해서 말씀드릴 예정입니다. 기존 분석기들에서 사용하는 상수 스트링 도메인에 간단한 정규식을 추가하여 분석기의 표현력을 높임으로써 분석의 정확도와 속도를 동시에 높일 수 있음을 설명드리고 정규식 추가 방법 및 관련된 문제점에 대해서도 말씀드릴 예정입니다.
</td>
<tr><th style="width:90px">발표</th>
  <th style="width:330px">
이홍기(KAIST)
  </th><th style="width:110px">시간</th><th style="width:110px">
15:50-15:55
  </th></tr>
<tr align="center"><th>제목 </th>
<td colspan="3" align="left"> 
JavaScript 정적분석을 위한 함수문맥 구분방법
</td>
<tr align="center"><th>요약 </th>
<td colspan="3" align="left"> 
정적분석에서 함수간 분석을 할 때, 함수문맥을 어떻게 구분하는지에 따라 다양한 함수문맥 구분방법이 존재한다. 함수문맥을 구분하지 않거나, 호출위치이력을 이용하는 방법을 주로 사용하고 있으며, 객체지향언어에서는 객체민감 함수문맥 구분법을 정적분석에서 함수 문맥을 구분하는데 이용하고 있다. JavaScript에서는 값들을 더 정확하게 유지하기위해, 함수 호출위치와 인자의 값까지 이용하여 구분하는 함수문맥 구분법을 제안하였다. 하지만 지금까지 제안된 JavaScript 정적분석을 위한 함수문맥 구분방법은 특정 기술을 잘 적용하기 위한 방안으로, 복잡한 JavaScript 프로그램을 분석하기에는 적절하지 않다. 우리는 함수 호출위치를 활용하는 함수문맥구분 방식이 아닌, 함수 호출상태를 이용한 함수문맥구분 방식을 이용하여 복잡한 JavaScript 프로그램을 분석하고자 한다.
</td>
<tr><th style="width:90px">발표</th>
  <th style="width:330px">
윤용호(서울대학교)
  </th><th style="width:110px">시간</th><th style="width:110px">
15:55-16:00
  </th></tr>
<tr align="center"><th>제목 </th>
<td colspan="3" align="left"> 
LLVM 컴파일러의 Alias Analysis 패스 검산하기
</td>
<tr align="center"><th>요약 </th>
<td colspan="3" align="left"> 
LLVM 컴파일러에 검증된 검산기를 장착하는 연구의 한 꼭지로, Alias Analysis 패스에 대해 검산하는 연구를 발표한다. Alias Analysis는 메모리 읽기, 쓰기가 얽힌 명령어들에 대해 최적화를 하기 위해서 여러 곳에서 사용된다. 어떤 두 포인터가 같은 주소를 가리킬 수 있는지, 혹은 어떤 함수가 특정 포인터의 영역을 건드릴 수 있는지 등등을 알려준다. 최적화 자체에 대한 검산과 최적화 근거로 사용되는 분석에 대한 검산을 분리하는 방식으로 앞으로의 확장을 편리하게 할 수 있다. 예를 들어, 현재 O1에서 O3까지의 옵션에서 기본적으로 사용되는 분석들 외에 새로운 분석이 추가될 경우에도 쉽게 대처할 수 있다. Alias Analysis 결과를 검산하는 방법과, 이를 최적화 검산에 활용할 수 있도록 하는 구조를 소개한다.
</td>
<tr><th style="width:90px">발표</th>
  <th style="width:330px">
최재승(서울대학교)
  </th><th style="width:110px">시간</th><th style="width:110px">
16:00-16:05	
  </th></tr>
<tr align="center"><th>제목 </th>
<td colspan="3" align="left"> 
바이너리 실행 파일의 버퍼 오버런 분석
</td>
<tr align="center"><th>요약 </th>
<td colspan="3" align="left"> 
이 발표는 바이너리 실행 파일에서 버퍼 오버런 오류를 찾아내는 분석기를 소개한다. 정적 분석은 프로그램 소스에서 오류를 찾아내는데 성공적으로 사용되어 왔다. 그러나 오늘날 많은 소프트웨어는 소스 코드 없이 바이너리 파일로만 공개되곤 한다. 따라서 바이너리 형태로도 정적 분석이 가능하다면 유용할 것이다. 소스 코드에는 선언된 배열의 크기와 같은 high-level 정보가 드러나지만, 바이너리에는 이러한 정보가 드러나지 않기 때문에 버퍼 오버런을 정의하고 탐지하는데 어려움이 있다. 이러한 문제를 해결하기 위한 아이디어와, 구현된 분석기의 실험 결과를 소개한다.
</td>
<tr><th style="width:90px">발표</th>
  <th style="width:330px">
이동권(서울대학교)
  </th><th style="width:110px">시간</th><th style="width:110px">
16:05-16:10
  </th></tr>
<tr align="center"><th>제목 </th>
<td colspan="3" align="left"> 
달라지는 실행흐름에 의한 변경 영향을 빠짐없이 잡아내기
</td>
<tr align="center"><th>요약 </th>
<td colspan="3" align="left"> 
이번 발표에서는 오염분석(taint analysis)을 기반으로 한 PL/SQL변경영향분석기 설계에 대해 말씀드리고자 합니다. 먼저 분석기설계의 큰 그림에 대해 말씀드릴 예정입니다. 저는 오염전파경로(taint propagation path)가 포함된 PL/SQL 의미구조(Concrete Semantics)를 새로이 정의하였습니다. 이 새로운 의미구조를 통해 프로그램에서 변경된 부분을 오염원(taint source)으로 잡고 실행도중 어떤 곳으로 오염이 전파되는지 알 수 있습니다. 또한 이 오염전파결과를 통해 어떤 지점에 변경영향이 생겼는지를 알 수 있습니다. 다음으로는 단순한 오염분석만으로는 찾아내기 힘들었던 변경영향지점에 대해 몇가지 소개를 해 드리고, 어떻게 이 문제를 해결했는지 소개해드리고자 합니다. 분기문(if/while), 예외처리(exception handling)이나 배열변경(assigning collecting values)에 의해 생기는 변경영향은 겉으로 드러나지 않는 이유에 의해 생기기 때문에 단순히 오염전파결과를 통해 정확히 짚어내기 힘들었습니다. 그 이유와 해결책에 대해서 소개해 드리도록 하겠습니다.
</td>
<tr><th style="width:90px">발표</th>
  <th style="width:330px">
김종권(서울대학교)
  </th><th style="width:110px">시간</th><th style="width:110px">
16:10-16:15
  </th></tr>
<tr align="center"><th>제목 </th>
<td colspan="3" align="left"> 
부울논리가 함수호출경로를 만들어주네요, 알람분류에 유용해요
</td>
<tr align="center"><th>요약 </th>
<td colspan="3" align="left"> 
본 발표에서는 소스-싱크 분석기의 알람이 참 혹은 거짓인지 사용자가 판단하는데 도움을 주는 시스템을 소개한다.  소스란 우리가 관심있는 값이 생성되는 지점, 싱크란 그 값이 쓰이는 지점을 의미한다. 분석기가 근사 해답을 주기 때문에, 사용자는 소스-싱크 경로의 실재 가능성을 육안으로 판단해야 한다. 이 사용자 판별과정은 가능한 경로의 갯수와 길이가 커질수록 어렵다.  이를 해결하기 위해 우리는 최단 소스-싱크 함수호출경로를 사용자에게 제시하고, 그것이 실재할 수 없는 경로인 경우, 사용자에게 그 이유를 논리식 형태로 제공받아 다른 최단 경로를 제공하는 사용자 상호작용 시스템을 만들었다. 사용자 제약식은 부울논리식이며 그 안에서 부울변수는 어떤 함수 호출이 경로에 포함되는지 아닌지를 의미한다.  이를 포맷스트링 버그 탐지 분석기에 적용한 결과, 15개의 C 오픈소스 프로그램에서 실제하는 버그를 시스템을 이용해 빠르게 찾을 수 있었다. 많은 경우 필요한 사용자 상호작용 횟수는 1-4번에 불과했다.
</td>

</body>
</html>
